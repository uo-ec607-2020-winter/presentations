---
title: "Fastest 100 metre times"
author: "Ethan Holdahl"
date: "`r format(Sys.time(), '%d %B %Y')`"
runtime: shiny
output:
  html_document:
    theme: yeti
    highlight: haddock 
    toc: yes
    toc_depth: 3
    toc_float: yes
    keep_md: true

---

```{r setup, include=FALSE}
## This next line sets the default behaviour for all R chunks in the .Rmd document.
## I recomend you take a look here: https://rmarkdown.rstudio.com/authoring_rcodechunks.html
knitr::opts_chunk$set(echo = TRUE, cache = TRUE, error = TRUE, dpi=300)
```

## Background

In class, we practiced webscraping with the Wikipedia page on the [Men's 100 metres world record progression](http://en.wikipedia.org/wiki/Men%27s_100_metres_world_record_progression). For this assignment, we're going to continue with a similar theme, except we won't only be limiting ourselves to world record times. The page that we're scraping will also have a few complications that require extra (or at least different) steps.

Here is the webpage: **[All-time men's best 100m](http://www.alltime-athletics.com/m_100ok.htm)**.

*<b>Note:</b> You are welcome to use the [women's all-time best 100m times](http://www.alltime-athletics.com/w_100ok.htm) if you prefer. However, please be aware that you may (will?) have to adjust some of the specific hints below. It will be become more obvious why once we get to the prediction section of the assignment.*

Now is good time to load any packages that you will be needing, as well as set your preferred plotting theme, etc. 

```{r libs, cache=F, message=F}
## Load and install the packages used in this project
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, rvest, readr, lubridate, data.table, broom, stats, sf, maps, rnaturalearth, leaflet, shiny)
```

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r eruptions, cache = F, echo=FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## 1) Read in the data

Take a look at the [webpage](http://www.alltime-athletics.com/m_100ok.htm) in your browser. We only want the information contained in the main table at the top (i.e. ignore the rolling starts, manual timing, etc.) Read this table into R and call the resulting object `m100_wp`.

*Hint: In class, we practised specifiying the correct HMTL nodes using CSS selectors and SelectorGadget. For this example, you may find it easier / more precise to rather use an xpath selector with the help of your browser's "Inspect" function. In other words, try `rvest::html_nodes(xpath="XPATH_HERE")`.*

```{r data}
#read in the data
m100_wp = read_html("http://www.alltime-athletics.com/m_100ok.htm") %>%
  html_nodes(xpath = "/html/body/center[3]/pre")

#print the result
m100_wp
```


## 2) Convert to a data frame


### 2.1) Try parsing with `rvest::html_table()`

With the Wikipedia example from class, we were able to parse an HTML table into a data frame simply by using `rvest::html_table()`. What happens if you try that here?

```{r 2.1}
#try to parse with html_table()
m100_wp %>%
  html_table()
```

**I get an error saying that the object isn't recognized as a table.**

### 2.2. Try parsing with `rvest::html_text()`

Unfortunately, the HTML object that we've read into R is old-school text. Luckily, we can still extract this text pretty easily into an R string. Do that and name the resulting object `m100_text` and show me the first 1000 characters.

*Hint: See `rvest::html_text()`. (I'd advise <b>not</b> to use the `fill = "TRUE"` option.) For printing the first 1000 characters, see the `substr()` function.*

```{r 2.2}
#parse instead with html_text()
m100_wp = m100_wp %>%
  html_text()

#print a small selection of the string
m100_wp %>%
  substr(1, 1000)
```

### 2.3. Convert to fixed-width format

So we basically have one loooong string. How, then, should we convert it to a data frame? The clue has already been given to you in the subheading of this section, but you should have noticed that fixed-width format of the data anyway from the web page itself. Use that information to convert the string into a data frame, which I want you to call `m100`. What does the resulting data frame look like? 

*Hint: See `?readr::read_fwf`. Pay particular attention to the option of guessing the fixed column positions based on the the position of empty columns, i.e. `read_fwf(OBJECT, fwf_empty(OBJECT))`. Don't worry about specifying column names yet. You may (should?) get some warning messages, but you can ignore those for the moment. Now would also be a good time to load the tidyverse if you haven't done so already.*

```{r 2.3}
#seperate the string into columns using fwf_empty()
m100_wp = read_fwf(m100_wp, fwf_empty(m100_wp ,col_names = c("rank", "time", "wind", "name","", "country", "hgg", "hih", "location", "date")))

#print the result
m100_wp
```

## 3) Inspect and fix

### 3.1) Fix athlete names

Our `read_fwf()` call has had some trouble correctly identifying athlete names; particularly those with middle names or double-barrelled surnames. This has also led to a mostly empty column in the data frame. (How many exactly?) Fix this issue by uniting the relevant columns and tidying up afterwards.

*Hint: In an ideal world, we would fill in the missing letters of the affected athletes, e.g. Leonard Myles-Mil<b>L</b>s or Kareem Streete-Tho<b>M</b>pson. However, that requires a tedious nested `ifelse()` (or, better, `case_when()`) statement, which I'm not worried about testing here. So just ignore any resulting mis-spellings that arise during the unite process.*

```{r 3.1}
#count how many rows have a non-na value in the mostly empty column
sum(!is.na(m100_wp$X5))

#string bind the columns together
changedNames = m100_wp %>%
  filter(!is.na(X5))%>%
  mutate(name = paste(name,X5)) %>%
  select(rank:name, country:date)

#print result
changedNames

#replacing the 61 records with values in column 5 and removing the column
m100_wp = m100_wp %>%
  filter(is.na(X5)) %>%
  select(rank:name, country:date) %>%
  rbind(changedNames) %>%
  arrange(time)

#print the result
m100_wp
```

### 3.2) Assign column names

You should now (hopefully) have nine columns. Assign them the following names: `c("rank", "time", "windspeed", "athlete", "country", "birth", "race_rank", "location", "date")`.

```{r 3.2}
#assigning column names
colnames(m100_wp) = c("rank", "time", "windspeed", "athlete", "country", "birth", "race_rank", "location", "date")
```

### 3.4 Convert columns to correct classes

Finally, convert your columns to the correct classes. Date columns should be converted to dates, numeric columns should be converted to numeric, etc.

*Hint: Check, but you should be able to ignore the few parsing failures that occur with converting date columns.*

```{r 3.4, warning=FALSE}
#converting column classes
m100_wp$rank = as.integer(m100_wp$rank)
m100_wp$time = as.numeric(m100_wp$time)
m100_wp$windspeed = as.numeric(m100_wp$windspeed)
m100_wp$windspeed[is.na(m100_wp$windspeed)] = 0
m100_wp$birth = dmy(m100_wp$birth)
m100_wp$date = dmy(m100_wp$date)
m100_wp
```

## 4) Plot the data
 
Plot the data, with the r %>%
ace date on the x-axis and time on the y-axis. Highlight Usain Bolt's times in red.

```{r 4}
#making the plot and overlaying Bolt's times in red
ggplot(data = m100_wp, aes(x = date, y = time)) +
  geom_point() +
  geom_point(data = filter(m100_wp, athlete == "Usain Bolt"), color = 2)
```

## 5) Subset to fastest times per year

It's hard to fit a sensible model to the above data. What might make more sense is to think of 100 metre times as following some kind of (approximately) deterministic process over the years. Subset the data to the fastest time recorded in each year. Call this new data frame `m100_yr` and then repeat the plot above, again highlighting Usain Bolt's times.

```{r 5}
#create a tibble for the fastest times each year
m100_yr = m100_wp %>%
  mutate(year = year(date)) %>%
  group_by(year) %>%
  summarise(time = min(time))

#print the tibble
m100_yr

#create a tibble for Bolt's fastest time each year
m100_yr_bolt = m100_wp %>%
  filter(athlete == "Usain Bolt") %>%
  mutate(year = year(date)) %>%
  group_by(year) %>%
  summarise(time = min(time))

#print the tibble
m100_yr_bolt

#find where Bolt's fastest time for a given year is equal to the fastest time that year
m100_yr_bolt_record = rbind(m100_yr,m100_yr_bolt)[duplicated(rbind(m100_yr,m100_yr_bolt)),]

#print the tibble
m100_yr_bolt_record

#plot the fastest times with Bolt's in red
ggplot(data = m100_yr, aes(x = year, y = time)) +
  geom_line(alpha = .5) +
  geom_point() +
  geom_point(data = m100_yr_bolt_record, color = 2)


```

## 6) Modeling and prediction

Imagine that you are back in the year **2005**. You are tasked with fitting a model of year-best 100m times up until that point. Importantly, your model will also be used to predict the trajectory of future 100m times.


### 6.1) Fit a model

Start by fitting a simple regression model of your choice, using data that would have been available to you then (you can include 2005). You are free to use whatever specification you prefer, but please be explicit by writing the model down. (Use dollar signs to demarcate LaTeX equations in R Markdown.) Please also show me the actual regression results in a nicely-formatted table.

*Hint: I'd advise excluding data from before 1975, since we don't have consecutive or consistent records before then.*

```{r 6.1}
#filter out all data after 2005, before 1975
m100_yr_2005 = m100_yr %>%
  filter(year<2006 & year>1974)

#run a linear regression
linear_reg = tidy(lm(time ~ year, data = m100_yr_2005))

#print the table
linear_reg
```

### 6.2) Prediction

Fast forward to the present day. Given your model and the available data in 2005, what year would you have predicted humanity reaching the current world record time of 9.58 seconds? How does this compare with the year that Usain Bolt actually set it (i.e. 2009). What do you make of this?


```{r 6.2}
#project forward
round((9.58-linear_reg$estimate[1])/linear_reg$estimate[2])
```

### 6.3) Plot your results

Provide a visual depiction of your prediction model. I basically want you to repeat your earlier plot from Question 4, but now with a (95 percent) prediction envelope. The prediction envelope should extend through both the "fitted" (<= 2005) _and_ "predicted" (2006--present) data periods. Make sure that these two periods are clearly demarcated in your plot.

*Hint: I recommend that you take a look at the generic `stats::predict.lm()` function, which can easily handle predictions out of sample and also has options for producing prediction/confidence intervals. Note that, while some of you may be tempted to use `geom_smooth()` for a simple visualization like this, you will likely run into difficulties predicting out of sample. There are some ways [around this](https://stats.stackexchange.com/questions/36207/how-to-predict-or-extend-regression-lines-in-ggplot2), but it ends up being more work than is worth IMO.*

```{r}
#creating prediction
conf_int = predict(lm(time ~ year, data = m100_yr_2005), filter(m100_yr, year>1974), interval = "confidence", level =.95)

#binding together with real data
m100_yr_proj = cbind(filter(m100_yr, year>1974),conf_int)

#printing results
m100_yr_proj

#seperating into fitted data
m100_yr_proj_fit = m100_yr_proj %>%
  filter(year<2006)

#printing results
m100_yr_proj_fit

#seperating into predicted data
m100_yr_proj_pred = m100_yr_proj %>%
  filter(year>2005)

#printing results
m100_yr_proj_pred

#creating the plot
ggplot(data = m100_yr_proj, aes(x = year, y = time)) +
  geom_point() +
  geom_point(data = m100_yr_bolt_record, color = 2) +
  geom_line(data = m100_yr_proj_fit, aes(x = year, y = fit), color = 6) +
  geom_line(data = m100_yr_proj_fit, aes(x = year, y = lwr), color = 6, alpha = .6) +
  geom_line(data = m100_yr_proj_fit, aes(x = year, y = upr), color = 6, alpha = .6) +
  geom_line(data = m100_yr_proj_pred, aes(x = year, y = fit), color = 4) +
  geom_line(data = m100_yr_proj_pred, aes(x = year, y = lwr), color = 4, alpha = .6) +
  geom_line(data = m100_yr_proj_pred, aes(x = year, y = upr), color = 4, alpha = .6) +
  labs(title = "Predicted yearly record 100m times", 
       subtitle = "Points where Usain Bolt holds the fastest time in that year are colored red",
       caption = "The fitted values and confidence intervals of the projection are depicted by the purple (fitted) and blue (projected) lines")
  
```


## 7) Map

### 7.1 Static map

Finally, go back to your original `m100` data frame, which contains all the data (i.e. not just the fastest time in each year). I want you to give me a sense of athletic achievement by country (including duplicate observations for the same athlete). Plot a world map, with a colour fill proportional to the number of fastest times that have been contributed by athletes of each country.

*Hint: Use the `sf`-compatible "countries" data frame from the `rnaturalearth` package that I showed you in the spatial lecture. This will come with a column of "iso_a3" country codes that you can match (i.e. join) to the "country" column of the `m100` data frame. There will likely be some mismatches because of inconsistencies in the ISO codes across these data frames. I won't be too strict about this, although you may find the `countrycode::countrycode()` function a helpful alternative.*

```{r 7.1}
#calculating count per country
m100_country_count = m100_wp %>%
  group_by(country) %>%
  summarise(n = n())

#Correcting country code names
m100_country_count$country[m100_country_count$country=="ANT"]="NLD"
m100_country_count$country[m100_country_count$country=="AHO"]="NLD"
m100_country_count$country[m100_country_count$country=="BAH"]="BHS"
m100_country_count$country[m100_country_count$country=="GER"]="DEU"
m100_country_count$country[m100_country_count$country=="AHO"]="NED"
m100_country_count$country[m100_country_count$country=="NED"]="NLD"
m100_country_count$country[m100_country_count$country=="NGR"]="NGA"
m100_country_count$country[m100_country_count$country=="POR"]="PRT"
m100_country_count$country[m100_country_count$country=="AHO"]="NED"
m100_country_count$country[m100_country_count$country=="RSA"]="ZAF"
m100_country_count$country[m100_country_count$country=="ZAM"]="ZMB"
m100_country_count$country[m100_country_count$country=="ZIM"]="ZWE"

#re-aggregating
m100_country_count = m100_country_count %>%
  group_by(country) %>%
  summarise(n = sum(n))

countries <- 
  ne_countries(returnclass = "sf") %>%
  select(country = iso_a3, geometry)

country_count = left_join(countries, m100_country_count, by = "country")

country_count %>%
  ggplot() +
  geom_sf(aes(fill = log(n))) +
  scale_fill_viridis_c(option = "A") +
  labs(title = "Number of recorded 100m times \nunder 10.1 seconds by athlete's country")


```


### 7.2. BONUS: Interactive map

One major downside of the above static map is that some powerhouses of world athletics are geographically tiny nations in the Carribean, which are very hard to see. For bonus points, I want you to try to plot an interactive map using **leaflet** or one of the derivative packages that I mentioned in the spatial lecture.
